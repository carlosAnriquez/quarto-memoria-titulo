<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.45">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>discusion – Proyecto memoria de título</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Proyecto memoria de título</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./resumen.html"> 
<span class="menu-text">Resumen</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./introduccion.html"> 
<span class="menu-text">Introducción</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./antecedentes.html"> 
<span class="menu-text">Antecedentes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./pregunta.html"> 
<span class="menu-text">Pregunta de investigación</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./hipotesis.html"> 
<span class="menu-text">Hipótesis</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./marco-metodologico.html"> 
<span class="menu-text">Metodología</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./resultados.html"> 
<span class="menu-text">Resultados</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./conclusiones.html"> 
<span class="menu-text">Conclusiones</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#discusión" id="toc-discusión" class="nav-link active" data-scroll-target="#discusión">7. Discusión</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="discusión" class="level2" style="text-align: justify">
<h2 class="anchored" data-anchor-id="discusión">7. Discusión</h2>
<p>En la historia política reciente de Chile, la relación entre Carabineros y ciudadanía ha estado marcada por bajos niveles de legitimidad y desconfianza con la policía uniformada. A su vez, los efectos del estallido social, han puesto en el debate público cual es rol de Carabineros en el control del orden público, así como cuáles son sus facultades respecto a esta labor. Desde la literatura especializada, se ha planteado la importancia de que la policía respete los procedimientos establecidos para mantener su legitimidad (Gerber et al., 2018).</p>
<p>Sin embargo, en una situación de violencia intergrupal, como es el caso de los enfrentamientos entre Carabineros y manifestantes en contexto de protesta, el procedimiento del uso de la fuerza resulta poco claro a los ojos de un observador ¿Qué nivel de violencia se justifica? ¿Cuándo se justifica?, una parte de la literatura plantea que más allá de los procedimientos y la legitimidad, la respuesta a estas preguntas puede ser ideológica por naturaleza (Gerber &amp; Jackson, 2016). En base a esta idea, se planteó la necesidad de esclarecer la relación entre la orientación política, como indicador resumido de la ideología política, y las justificaciones de la violencia.</p>
<p>Así también, el resurgimiento esporádico del conflicto entre Carabineros y manifestantes demuestran lo frágil y complejas que son las interacciones entre la ciudadanía y la policía uniformada en nuestro país. En este contexto de violencia intergrupal, el miedo como emoción social puede tener un rol en el reconocimiento de la identidad del sujeto en su relación con el grupo y la evaluación que se realiza del contexto (Yzerbyt et al., 2003). Así, entre identidad y reconocimiento, se dibujan espacio de inclusión y exclusión respecto hacia quienes y por qué se justifica la violencia.</p>
<p>En este espacio teórico, es que se buscó responder de qué forma se relaciona la orientación política con el miedo a los actores relacionados a la protesta social en la justificación de la violencia en contexto de protesta en Chile el año 2022.</p>
<p>Así, se plantearon cinco hipótesis distintas: 1. individuos de orientación política de derecha, tienen mayor probabilidad de justificar la violencia policial, mientras que individuos de orientación política de izquierda, tienen mayor probabilidad de justificar la violencia de manifestantes. 2. individuos que indiquen mayor miedo a manifestantes, tienen mayor probabilidad de justificar la violencia de Carabineros, mientras que individuos que indiquen mayor miedo a Carabineros, tienen mayor probabilidad de justificar la violencia de manifestantes. 3. hay una percepción diferenciada del miedo a los actores relacionados con la protesta social según orientación política. Personas de derecha sienten más miedo por los manifestantes, mientras que personas de izquierda sienten más miedo a Carabineros. 4. existe un efecto interactivo entre orientación política de derecha y el miedo a manifestantes, aumentando la probabilidad de justificar la violencia policial. 5. existe un efecto interactivo entre orientación política de izquierda y el miedo a Carabineros, aumentando la probabilidad de justificar la violencia de manifestantes.</p>
<p>Respecto a la hipótesis 1, se puede advertir que existe evidencia suficiente para confirmarla, en cuanto la orientación política de derecha tiene un efecto positivo y estadísticamente significativo en la justificación de la violencia de Carabineros, aun después de controlar por miedo a manifestantes violentos y las variables sociodemográficas seleccionadas. Para el modelo 3, los encuestados de centro tienen un 35% más de probabilidad de justificar esta forma de violencia en contraste con quienes se identifican de izquierda (OR: 1.35, p &lt; 0.05), mientras que los encuestados de derecha tienen un 58% más de justificar la violencia de Carabineros en comparación a los encuestados de izquierda.</p>
<p>Así también, hay una relación estadísticamente significativa y positiva entre la orientación política de izquierda y la justificación de la violencia de manifestantes, controlando por miedo a Carabineros y las variables sociodemográficas de interés. Para el modelo 3, los encuestados de centro tienen un 44% menos de probabilidad de justificar la violencia de manifestantes en comparación con quienes se identifican de izquierda (OR: 0.56, p &lt; 0.001), mientras que encuestados de derecha tienen un 49% menos de probabilidad de justificar la violencia de manifestantes respecto a encuestados de izquierda (OR: 0.51, p &lt; 0.001). Así también, los encuestados apolíticos tienen un 47% menos probabilidad de justificar esta forma de violencia respecto a quienes se identifican de izquierda (OR: 0.53, p &lt; 0.001).</p>
<p>Estos hallazgos indican que la justificación de la violencia de manifestantes es una percepción política relacionado con la izquierda, acercando las categorías de centro y apolítico a las percepciones de la derecha política, mientras que la justificación de la violencia de Carabineros se relaciona con el centro y la derecha política.</p>
<p>Respecto a la conexión entre miedo a los actores relacionados con la protesta social y justificación de la violencia, existe evidencia parcial para la hipótesis 2. Por un lado, el miedo a manifestantes tiene una relación positiva y significativa en la justificación de la violencia de Carabineros, aún después de controlar por orientación política y variables sociodemográficas. Para el modelo 3, quienes indican sentir poco miedo a manifestantes violentos tienen un 124% más de probabilidad de justificar la violencia de Carabineros en comparación con quienes indican sentir nada de miedo a manifestantes violentos, mientras que quienes sienten mucho miedo a manifestantes violentos, tienen un 98% más de probabilidad de justificar esta forma de violencia respecto a quienes sienten nada de miedo a manifestantes violentos. Por otra parte, el efecto del miedo a Carabineros no es estadísticamente significativo en la justificación de la violencia de manifestantes.</p>
<p>Respecto a la hipótesis 3, que plantea una percepción diferenciada del miedo a los actores relacionados con la protesta social según orientación política, los resultados obtenidos muestran evidencia parcial, pues personas de izquierda y derecha sienten más miedo por manifestantes violentos que por el accionar de Carabineros en las manifestaciones. Sin embargo, aunque el promedio de miedo a manifestantes violentos es mayor que el promedio de miedo a Carabineros para todas las orientaciones políticas, si existe una percepción diferenciada en la medida en que la diferencia entre estos promedios es importante. Por ejemplo, el promedio de miedo a manifestantes en los encuestados de derecha es de 4.21, frente a 3.8 para los encuestados de izquierda. También, el promedio de miedo al accionar de Carabineros es de 2.72 para los encuestados derecha y de 3.8 para quienes se identifican con la izquierda.</p>
<p>En segundo lugar, en el continuo izquierda-derecha es necesario ubicar a quienes se identifican como de centro o apolíticos, en cuanto estas categorías representan un espacio para quienes presentan menores niveles de politización. Respecto a estos grupos, podemos indicar dos alternativas: 1. Tendencias mixtas; 2. Preferencias autoritarias. Los hallazgos en el marco de esta investigación no permiten decantar por ninguna de las dos opciones, no obstante, respecto a la justificación de la violencia, los promedios de estos grupos son comparables a los encuestados de derecha, pero con niveles más altos de miedo tanto hacia Carabineros como hacia manifestantes violentos.</p>
<p>La evidencia recopilada también permite rechazar las hipótesis 4 y 5, En cuanto el efecto de interacción entre orientación política de derecha y miedo a manifestantes violentos no es estadísticamente significativo en la justificación de la violencia de Carabineros, como tampoco lo es la interacción entre orientación política de izquierda y miedo a Carabineros en la justificación de la violencia de manifestantes. Aunque se puede argumentar que el miedo a los actores relacionados con la protesta social actúa como variable moderadora (Ato &amp; Vallejo, 2010), alterando la magnitud de la relación entre orientación política y la justificación de la violencia, esta moderación es parcial y no toma forma de una interacción.</p>
<p>Así también, las variables de control entregan información valiosa respecto a los grupos que justifican los dos tipos de violencia estudiados. El nivel educativo resultó ser especialmente significativo en la justificación de la violencia de manifestantes. Un nivel educativo de primaria y secundaria básica, o un nivel de secundaria alta, disminuye en un 37% la probabilidad de justificar esta forma de violencia respecto a los encuestados con un nivel de primaria incompleta. Así también, un nivel educativo terciario o de postgrado disminuye en un 50 % la probabilidad de justificar la violencia de manifestantes respecto a quienes tienen un nivel de primaria incompleta. También, para la justificación de la violencia de Carabineros, un nivel educativo de primaria y secundaria baja aumenta en un 46% la probabilidad de justificar esta forma de violencia en comparación a quienes tienen un nivel de primaria incompleta.</p>
<p>La edad resultó ser significativa respecto a ambas formas de violencia. Por un lado, a mayor edad, la probabilidad de justificar la violencia de Carabineros aumenta en un 1%, mientras que, para la justificación de la violencia de manifestantes, a medida en que aumenta la edad, la probabilidad disminuye en un 2%. Finalmente, cabe mencionar que a diferencia de estudios anteriores (Gerber et al., 2018), la pertenencia a un grupo indígena no resultó ser significativo estadísticamente para la justificación de la violencia de Carabineros o manifestantes.</p>
<p>Aunque existen diversos estudios previos sobre justificación de la violencia en contexto de protesta (Rottenbacher &amp; Schmitz, 2013; Gerber et al., 2022; Venegas, 2022), buscamos aportar con una perspectiva novedosa al integrar el miedo y la orientación política como determinantes. De forma general, los hallazgos presentados suman evidencia respecto a la naturaleza ideológica de la justificación de la violencia, así también, abre espacios de investigación respecto al rol de las emociones en las justificaciones de la violencia.</p>
<p>En este sentido, los hallazgos recogidos permiten contribuir a la literatura especializada en tres aspectos distintos: en primer lugar, aporta nueva evidencia respecto a la forma que influye la orientación política en la justificación de la violencia en contexto de protesta. Solo la orientación política de izquierda se asocia a una mayor justificación de la violencia de manifestantes, mientras que ser de centro o de derecha se asocia a una mayor justificación de la violencia de Carabineros.</p>
<p>En segundo lugar, aporta a la comprensión del miedo a los actores relacionados con la protesta social. Respecto a ello, la información proporcionada indica que el miedo al accionar de Carabineros en las manifestaciones no influye en la justificación de la violencia de manifestantes, no obstante, el miedo a manifestantes violentos si influencia la justificación de la violencia de Carabineros. Esto puede interpretarse como un signo de legitimidad policial, en la medida en que el miedo hacia este grupo no significa una justificación de la violencia a manifestantes.</p>
<p>En tercer lugar, los hallazgos recogidos en esta investigación resaltan el rol del nivel educativo como uno de los factores individuales que más afecta la justificación de ambas formas de violencia estudiadas. Respecto a la justificación de la violencia de Carabineros, un nivel educativo de primaria y secundaria baja aumenta la probabilidad de justificar esta forma de violencia en comparación a los encuestados con primaria incompleta. Para el caso de la justificación de la violencia de manifestantes, un nivel educativo de primaria y secundaria básica, o un nivel de secundaria alta, disminuye en un 37% la probabilidad de justificar esta forma de violencia respecto a los encuestados con un nivel de primaria incompleta. Así también, un nivel educativo terciario o de postgrado disminuye en un 50 % la probabilidad de justificar la violencia de manifestantes respecto a quienes tienen un nivel de primaria incompleta.</p>
</section>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>